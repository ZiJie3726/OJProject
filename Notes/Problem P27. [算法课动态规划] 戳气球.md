# Problem P27. [算法课动态规划] 戳气球

![picture 0](.assets_IMG/Problem%20P27.%20%5B%E7%AE%97%E6%B3%95%E8%AF%BE%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D%20%E6%88%B3%E6%B0%94%E7%90%83/IMG_20231019-153652.png)  

```c++
#include <iostream>
#include <vector>
using namespace std;

// 定义一个函数，返回戳破所有气球能得到的最大硬币数
int maxCoins(vector<int>& nums) {
    // 在数组两端添加1，方便处理边界情况
    nums.insert(nums.begin(), 1);
    nums.push_back(1);
    // 定义一个二维数组dp，dp[i][j]表示戳破区间(i,j)内的所有气球能得到的最大硬币数
    int n = nums.size();
    vector<vector<int>> dp(n, vector<int>(n, 0));
    // 从下往上，从左往右遍历dp数组，填充每个子问题的最优解
    for (int i = n - 2; i >= 0; i--) {
        //当i=n-2时，j=i+2=n，这个区间(0,n-1)就是我们要求的最终结果，不需要再进入循环体了。
        //而当i<n-2时，j=i+2<n，这个区间(i,j)是一个子问题，需要进入循环体求解。
        for (int j = i + 2; j < n; j++) {
            // 对于每个区间(i,j)，枚举其中的每个气球k，假设最后戳破k，那么可以得到的硬币数为
            // dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]
            // 取其中的最大值作为dp[i][j]的值
            for (int k = i + 1; k < j; k++) {
                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]);
            }
        }
    }
    // 返回最终结果，即戳破区间(0,n-1)内的所有气球能得到的最大硬币数
    return dp[0][n-1];
}

// 测试代码
int main() {
    vector<int> nums = {3, 1, 5, 8}; // 定义一个测试用例
    cout << maxCoins(nums) << endl; // 输出结果，应为167
    return 0;
}
```

`dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]`
这个表达式是用来计算戳破区间(i,j)内的所有气球能得到的最大硬币数的。其中，k是区间(i,j)内的一个气球，假设我们最后戳破它，那么我们可以得到以下的硬币数：

- `dp[i][k]`：这是戳破区间(i,k)内的所有气球能得到的最大硬币数，这是一个子问题，我们已经在之前的循环中求出了它的值。
- `dp[k][j]`：这是戳破区间(k,j)内的所有气球能得到的最大硬币数，这也是一个子问题，我们也已经在之前的循环中求出了它的值。
- `nums[i] * nums[k] * nums[j]`：这是戳破气球k能得到的硬币数，因为当我们戳破k时，它的左右相邻的气球就是i和j，所以它们的乘积就是硬币数。

所以，`dp[i][k] + dp[k][j] + nums[i] * nums[k] * nums[j]`就是在假设最后戳破k的情况下，戳破区间(i,j)内的所有气球能得到的硬币数。我们要枚举区间(i,j)内的所有可能的k，取其中的最大值作为`dp[i][j]`的值。这样就可以保证我们找到了戳破所有气球能得到的最大硬币数。

>为什么当我们戳破k时，它的左右相邻的气球就是i和j，所以它们的乘积就是硬币数。

这是因为我们是按照最后戳破k的顺序来计算的，也就是说，在我们戳破k之前，区间(i,k)和区间(k,j)内的所有气球都已经被戳破了，所以k的左右相邻的气球就是i和j，它们没有被戳破，还在原来的位置上。你可以想象一下，如果你有一排气球，你从中间开始戳破一个，然后再戳破它左边的一个，再戳破它右边的一个，依次类推，直到最后只剩下两个气球在两端，这时候你戳破其中一个，就可以得到它们的乘积作为硬币数。这个问题就是用这样的思路来解决的。
