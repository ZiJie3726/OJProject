# Problem P25. [算法课动态规划] 整数拆分

![picture 0](.assets_IMG/Problem%20P25.%20%5B%E7%AE%97%E6%B3%95%E8%AF%BE%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%5D%20%E6%95%B4%E6%95%B0%E6%8B%86%E5%88%86/IMG_20231018-002154.png)  

这个问题可以使用动态规划来解决。我们可以定义一个数组 `dp`，其中 `dp[i]` 表示将整数 `i` 拆分成多个正整数的和后，这些整数的乘积的最大值。

动态规划的思路如下：

1. 对于整数 `i`，我们可以将其拆分为两部分：`j` 和 `i-j`，其中 `j` 是 `i` 的一个正整数拆分的一部分，而 `i-j` 是剩余部分。

2. 我们可以尝试将 `j` 进一步拆分，如果拆分后的乘积大于 `j` 本身，就将 `j` 拆分。

3. 我们可以通过比较 `j * (i-j)` 和 `j * dp[i-j]` 来决定是否将 `j` 进一步拆分。这是因为我们要取最大的乘积。

4. 我们遍历 `j` 的所有可能值，找到 `j` 的最大乘积，然后更新 `dp[i]`。

5. 最后，`dp[n]` 就是将整数 `n` 拆分后可以获得的最大乘积。

以下是使用动态规划的C++代码示例：

```cpp
#include <vector>

using namespace std;

int integerBreak(int n) {
    vector<int> dp(n + 1, 0);

    for (int i = 2; i <= n; i++) {
        for (int j = 1; j < i; j++) {
            dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
        }
    }

    return dp[n];
}
```

这个代码使用了动态规划来计算将整数 `n` 拆分后可以获得的最大乘积。`dp[n]` 包含了所有整数 `i` 的最大乘积，其中 `2 <= i <= n`。我们通过遍历所有可能的 `j` 值来计算 `dp[n]` 的值，最后返回 `dp[n]` 即可。
